(()=>{"use strict";var e={27:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=async function(e){const t=e.cleo;e.get("/api/queues",(async(e,s)=>{try{const e=t.getQueueManager(),a=await e.getAllTasks();return r.logger.info("File: queues.ts üìã, Line: 13, Function: GET /api/Queues;",{tasksCount:a.length}),s.send({tasks:a})}catch(e){return r.logger.error("File: queues.ts ‚ùå, Line: 19, Function: GET /api/queues;",{error:e}),s.status(500).send({error:"Failed to fetch tasks"})}})),e.post("/api/queues",(async(e,s)=>{try{const{name:a,data:o,options:i}=e.body,n=t.getQueueManager(),u=await n.addTask(a,o,i);return r.logger.info("File: queues.ts ‚ûï, Line: 31, Function: POST /api/queues;",{taskId:u.id,taskName:u.name}),s.send(u)}catch(e){return r.logger.error("File: queues.ts ‚ùå, Line: 38, Function: POST /api/queues;",{error:e}),s.status(500).send({error:"Failed to create task"})}})),e.delete("/api/queues/:taskId",(async(e,s)=>{try{const{taskId:a}=e.params,o=t.getQueueManager();return await o.removeTask(a)?(r.logger.info("File: queues.ts üóëÔ∏è, Line: 51, Function: DELETE /api/queues/:taskId;",{taskId:a}),s.send({message:"Task removed successfully"})):(r.logger.warn("File: queues.ts ‚ö†Ô∏è, Line: 55, Function: DELETE /api/queues/:taskId;",{taskId:a,message:"Task not found"}),s.status(404).send({error:"Task not found"}))}catch(e){return r.logger.error("File: queues.ts ‚ùå, Line: 62, Function: DELETE /api/queues/:taskId;",{error:e}),s.status(500).send({error:"Failed to remove task"})}}))};const r=s(749)},89:function(e,t,s){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.createServer=n,t.startServer=u;const a=r(s(446)),o=s(749),i=r(s(27));async function n(e){const t=(0,a.default)({logger:!1});return t.cleo=e,await t.register(i.default),t.setErrorHandler(((e,t,s)=>{o.logger.error("File: server.ts ‚ùå, Line: 14, Function: errorHandler;",{error:e,path:t.url,method:t.method}),s.status(500).send({error:"Internal Server Error"})})),t.setNotFoundHandler(((e,t)=>{o.logger.warn("File: server.ts ‚ö†Ô∏è, Line: 24, Function: notFoundHandler;",{path:e.url,method:e.method}),t.status(404).send({error:"Route not found"})})),t}async function u(e,t=3001){try{const s=await n(e);await s.listen({port:t,host:"0.0.0.0"}),o.logger.info("File: server.ts üöÄ, Line: 39, Function: startServer;",{message:`Server listening on port ${t}`})}catch(e){o.logger.error("File: server.ts ‚ùå, Line: 43, Function: startServer;",{error:e,message:"Failed to start server"}),process.exit(1)}}const c=s(783).Cleo.getInstance();c.configure({redis:{host:"localhost",port:6379}}),u(c)},481:function(e,t,s){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.redisConnection=t.RedisConnection=t.RedisInstance=void 0;const a=r(s(657)),o=s(749);var i;!function(e){e.DEFAULT="default",e.QUEUE="queue",e.WORKER="worker",e.CACHE="cache"}(i||(t.RedisInstance=i={}));class n{connections=new Map;initializeInstance(e,t){o.logger.info("File: redis.ts üîå, Line: 15, Function: initializeInstance; Initializing Redis connection",{instanceId:e});const s={host:t.REDIS_HOST,port:parseInt(t.REDIS_PORT,10),password:t.REDIS_PASSWORD,tls:"true"===t.REDIS_TLS?{}:void 0,db:t.REDIS_DB?parseInt(t.REDIS_DB,10):0},r=new a.default(s);return this.connections.set(e,r),o.logger.info("File: redis.ts üîå, Line: 39, Function: initializeInstance; Redis connection initialized",{instanceId:e}),r.on("error",(t=>{o.logger.error("File: redis.ts ‚ùå, Line: 30, Function: initializeInstance; Redis connection error",{error:t,instanceId:e})})),r}getConfig(e=i.DEFAULT){return this.connections.get(e)?.options}getInstance(e=i.DEFAULT){const t=this.connections.get(e);if(!t)throw new Error(`Redis connection not initialized for instance: ${e}`);return t}}t.RedisConnection=n,t.redisConnection=new n},361:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.initializeTaskDecorator=function(e){i=e},t.task=function(e={}){return function(t,s,n){const u=n.value,c=String(s);if(!i)throw new Error("Task decorator used before Cleo initialization");const l=e.queue||"default",g=i.getQueueManager();g.getQueue(l)||(r.logger.warn("üî• Task Decorator: No queue found for",{file:"task.ts",line:26,function:c,queueName:l}),g.initializeQueue(l,{connection:o.redisConnection.getInstance("default")}));const d=g.getWorker(l);if(!d)throw new Error(`No worker found for queue ${l}`);return d.registerTask(c,(function(...e){return r.logger.debug("üéØ Task Decorator: Executing task",{file:"task.ts",line:75,function:c,args:e}),u.apply(this,e)})),r.logger.info("üéØ Task Decorator: Task registered",{file:"task.ts",line:46,function:c,taskState:a.TaskState.WAITING,group:e.group}),n.value=async function(...t){const s=Date.now();let o;try{const i={...e,id:`${c}-${Date.now()}`,timeout:e.timeout||3e4,maxRetries:e.maxRetries||3};o=i.id,r.logger.debug("üöÄ Task Decorator: Creating task",{file:"task.ts",line:100,function:c,taskId:o,options:i});const n=await g.addTask(c,{args:t,context:this},i);return i.group?(await g.addTaskToGroup(n.id,i.group),r.logger.debug("üë• Task Decorator: Task added to group",{file:"task.ts",line:85,function:c,taskId:n.id,group:i.group}),new Promise(((e,t)=>{let u,l,d=0;const p=()=>{clearInterval(l),clearTimeout(u)},k=async e=>{p(),d<i.maxRetries?(d++,r.logger.warn("‚ö†Ô∏è Task Decorator: Retrying task",{file:"task.ts",line:150,function:c,taskId:o,error:e,retry:d}),await new Promise((e=>setTimeout(e,1e3*d))),f()):t(e)},f=()=>{l=setInterval((async()=>{try{const t=await g.getTask(n.id);if(!t)return void await k(new Error("Task not found"));if(t.state===a.TaskState.FAILED)return void await k(new Error(t.error||"Task failed"));if(t.state!==a.TaskState.WAITING){p();const a=Date.now()-s;r.logger.info("‚úÖ Task Decorator: Task completed",{file:"task.ts",line:180,function:c,taskId:o,executionTime:a,result:t.result}),e(t.result)}}catch(e){await k(e instanceof Error?e:new Error(String(e)))}}),1e3),u=setTimeout((async()=>{await k(new Error("Task processing timeout"))}),i.timeout)};f()}))):(r.logger.info("‚úÖ Task Decorator: Non-grouped task completed",{file:"task.ts",line:210,function:c,taskId:o,executionTime:Date.now()-s,result:n.result}),n.result)}catch(t){const a=Date.now()-s;throw r.logger.error("‚ùå Task Decorator: Task execution failed",{file:"task.ts",line:220,function:c,taskId:o,error:t,executionTime:a,group:e.group}),t}},Object.assign(n,{configurable:!0,enumerable:!0,writable:!0})}};const r=s(749),a=s(815),o=s(783);let i=null},152:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TaskGroup=void 0;const r=s(815),a=s(749);t.TaskGroup=class{redis;groupKey;stateKey;processingKey;processingOrderKey;queueManager=null;worker=null;constructor(e,t){this.redis=e,this.groupKey=`group:${t}:tasks`,this.stateKey=`group:${t}:state`,this.processingKey=`group:${t}:processing`,this.processingOrderKey=`group:${t}:order`,a.logger.info("üë• TaskGroup: initialized",{file:"taskGroup.ts",line:20,function:"constructor",groupName:t})}connect(e,t){this.queueManager=e,this.worker=t,a.logger.info("üîå TaskGroup: connected to QueueManager and Worker",{file:"taskGroup.ts",line:45,function:"connect"})}async addTask(e){try{await this.redis.sadd(this.groupKey,e);const t=Date.now();if(await this.redis.zadd(this.processingOrderKey,t.toString(),e),await this.redis.hset(this.stateKey,e,r.TaskStatus.WAITING),this.queueManager){const t=await this.queueManager.getTask(e);t&&(t.state=r.TaskState.WAITING,await this.queueManager.updateTask(t))}await this.updateStats(),a.logger.debug("‚ûï TaskGroup: task added",{file:"taskGroup.ts",line:31,function:"addTask",taskId:e,groupKey:this.groupKey})}catch(t){throw a.logger.error("‚ùå TaskGroup: failed to add task",{file:"taskGroup.ts",line:39,function:"addTask",taskId:e,error:t}),t}}async updateStats(){try{const e=await this.redis.hgetall(this.stateKey),t={total:Object.keys(e).length,active:0,completed:0,failed:0,paused:0};Object.values(e).forEach((e=>{switch(e){case r.TaskStatus.ACTIVE:t.active++;break;case r.TaskStatus.COMPLETED:t.completed++;break;case r.TaskStatus.FAILED:t.failed++;break;case r.TaskStatus.PAUSED:t.paused++}})),await this.redis.hmset(`${this.groupKey}:stats`,t),a.logger.debug("üìä TaskGroup: stats updated",{file:"taskGroup.ts",line:150,function:"updateStats",stats:t})}catch(e){a.logger.error("‚ùå TaskGroup: failed to update stats",{file:"taskGroup.ts",line:159,function:"updateStats",error:e})}}async removeTask(e){try{await Promise.all([this.redis.srem(this.groupKey,e),this.redis.hdel(this.stateKey,e),this.redis.zrem(this.processingOrderKey,e),this.redis.srem(this.processingKey,e)]),a.logger.debug("‚ûñ TaskGroup: task removed",{file:"taskGroup.ts",line:54,function:"removeTask",taskId:e})}catch(t){throw a.logger.error("‚ùå TaskGroup: failed to remove task",{file:"taskGroup.ts",line:61,function:"removeTask",taskId:e,error:t}),t}}async getTasks(){try{return await this.redis.smembers(this.groupKey)}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to get tasks",{file:"taskGroup.ts",line:74,function:"getTasks",error:e}),e}}async getTasksWithDetails(){try{if(!this.queueManager)throw new Error("TaskGroup not connected to QueueManager");const e=await this.getTasks();return(await Promise.all(e.map((e=>this.queueManager.getTask(e))))).filter((e=>null!==e))}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to get tasks with details",{file:"taskGroup.ts",line:74,function:"getTasksWithDetails",error:e}),e}}async getTaskStatus(e){try{return await this.redis.hget(this.stateKey,e)}catch(t){throw a.logger.error("‚ùå TaskGroup: failed to get task status",{file:"taskGroup.ts",line:87,function:"getTaskStatus",taskId:e,error:t}),t}}async updateTaskStatus(e,t){try{if(!await this.redis.sismember(this.groupKey,e))throw new Error(`Task ${e} not found in group`);if(await this.redis.hset(this.stateKey,e,t),this.queueManager){const s=await this.queueManager.getTask(e);s&&(s.state=this.mapTaskStatusToState(t),await this.queueManager.updateTask(s))}await this.updateStats(),a.logger.debug("üîÑ TaskGroup: task status updated",{file:"taskGroup.ts",line:104,function:"updateTaskStatus",taskId:e,status:t})}catch(s){throw a.logger.error("‚ùå TaskGroup: failed to update task status",{file:"taskGroup.ts",line:112,function:"updateTaskStatus",taskId:e,status:t,error:s}),s}}mapTaskStatusToState(e){switch(e){case r.TaskStatus.ACTIVE:return r.TaskState.ACTIVE;case r.TaskStatus.COMPLETED:return r.TaskState.COMPLETED;case r.TaskStatus.FAILED:return r.TaskState.FAILED;case r.TaskStatus.WAITING:return r.TaskState.WAITING;case r.TaskStatus.DELAYED:return r.TaskState.DELAYED;default:return r.TaskState.UNKNOWN}}async getStats(){try{const e=await this.redis.hgetall(`${this.groupKey}:stats`);return Object.keys(e).length>0?{total:parseInt(e.total)||0,active:parseInt(e.active)||0,completed:parseInt(e.completed)||0,failed:parseInt(e.failed)||0,paused:parseInt(e.paused)||0}:(await this.updateStats(),this.getStats())}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to get stats",{file:"taskGroup.ts",line:159,function:"getStats",error:e}),e}}async processNextTask(){if(!this.queueManager||!this.worker)throw new Error("TaskGroup not connected to QueueManager and Worker");try{const e=await this.getNextTask();if(!e)return;const t=await this.queueManager.getTask(e);if(!t)return void a.logger.warn("‚ö†Ô∏è TaskGroup: task not found",{file:"taskGroup.ts",line:150,function:"processNextTask",taskId:e});await this.updateTaskStatus(e,r.TaskStatus.ACTIVE),t.state=r.TaskState.ACTIVE,await this.queueManager.updateTask(t);const s=this.worker.getTaskHandler(t.name);if(!s)throw new Error(`No handler found for task ${t.name}`);try{const a=await s(t.data.args);t.result=a,t.state=r.TaskState.COMPLETED,await this.completeTask(e)}catch(s){t.state=r.TaskState.FAILED,t.error=s instanceof Error?s.message:String(s),await this.updateTaskStatus(e,r.TaskStatus.FAILED)}await this.queueManager.updateTask(t)}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to process next task",{file:"taskGroup.ts",line:190,function:"processNextTask",error:e}),e}}async startProcessing(){if(!this.queueManager||!this.worker)throw new Error("TaskGroup not connected to QueueManager and Worker");try{for(;await this.hasAvailableTasks();)await this.processNextTask();a.logger.info("‚úÖ TaskGroup: finished processing all tasks",{file:"taskGroup.ts",line:210,function:"startProcessing"})}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to process tasks",{file:"taskGroup.ts",line:216,function:"startProcessing",error:e}),e}}async pauseAll(){try{const e=await this.getTasks();await Promise.all(e.map((e=>this.updateTaskStatus(e,r.TaskStatus.PAUSED)))),a.logger.info("‚è∏Ô∏è TaskGroup: all tasks paused",{file:"taskGroup.ts",line:173,function:"pauseAll",tasksCount:e.length})}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to pause all tasks",{file:"taskGroup.ts",line:180,function:"pauseAll",error:e}),e}}async resumeAll(){try{const e=await this.getTasks();await Promise.all(e.map((e=>this.updateTaskStatus(e,r.TaskStatus.ACTIVE)))),a.logger.info("‚ñ∂Ô∏è TaskGroup: all tasks resumed",{file:"taskGroup.ts",line:194,function:"resumeAll",tasksCount:e.length})}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to resume all tasks",{file:"taskGroup.ts",line:201,function:"resumeAll",error:e}),e}}async getNextTask(){try{const e=await this.redis.zrange(this.processingOrderKey,0,0);if(0===e.length)return null;const t=e[0];return await this.redis.zrem(this.processingOrderKey,t),await this.redis.sadd(this.processingKey,t),a.logger.debug("‚è≠Ô∏è TaskGroup: next task selected",{file:"taskGroup.ts",line:220,function:"getNextTask",taskId:t}),t}catch(e){throw a.logger.error("‚ùå TaskGroup: failed to get next task",{file:"taskGroup.ts",line:230,function:"getNextTask",error:e}),e}}async completeTask(e){try{await Promise.all([this.redis.srem(this.processingKey,e),this.updateTaskStatus(e,r.TaskStatus.COMPLETED)]),a.logger.debug("‚úÖ TaskGroup: task completed",{file:"taskGroup.ts",line:248,function:"completeTask",taskId:e})}catch(t){throw a.logger.error("‚ùå TaskGroup: failed to complete task",{file:"taskGroup.ts",line:255,function:"completeTask",taskId:e,error:t}),t}}async hasAvailableTasks(){const e=await this.redis.smembers(this.groupKey),t=await this.redis.smembers(this.processingKey);return e.length>t.length}}},783:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Worker=t.WorkerState=t.GroupOperation=t.ObserverEvent=t.LogLevel=t.TaskPriority=t.TaskStatus=t.TaskState=t.TaskObserver=t.TaskGroup=t.QueueManager=t.redisConnection=t.Cleo=void 0;const r=s(361),a=s(433),o=s(749),i=s(481);Object.defineProperty(t,"redisConnection",{enumerable:!0,get:function(){return i.redisConnection}});const n=s(361);class u{static instances=new Map;queueManager=null;isConfigured=!1;instanceId;constructor(e=i.RedisInstance.DEFAULT){this.instanceId=e}static getInstance(e=i.RedisInstance.DEFAULT){return u.instances.has(e)||(o.logger.info("File: index.ts üîÑ, Line: 22, Function: getInstance; Creating new Cleo instance",{instanceId:e}),u.instances.set(e,new u(e))),u.instances.get(e)}configure(e){try{if(o.logger.info("File: index.ts ‚öôÔ∏è, Line: 36, Function: configure; Configuring Cleo instance",{instanceId:this.instanceId,redisHost:e.redis.host,redisPort:e.redis.port}),!e.redis.host||!e.redis.port)throw new Error("Redis host and port are required");const t={REDIS_HOST:e.redis.host,REDIS_PORT:e.redis.port.toString(),REDIS_PASSWORD:e.redis.password,REDIS_TLS:e.redis.tls?"true":void 0,REDIS_DB:e.redis.db?.toString(),INSTANCE_ID:this.instanceId};o.logger.info("File: index.ts üîå, Line: 43, Function: configure; Redis configuration",{redisConfig:t}),i.redisConnection.initializeInstance(this.instanceId,t),this.queueManager=new a.QueueManager("default",this.instanceId,{},e.worker),(0,n.initializeTaskDecorator)(this),this.isConfigured=!0,o.logger.info("File: index.ts ‚úÖ, Line: 56, Function: configure; Cleo configuration complete",{instanceId:this.instanceId})}catch(e){throw o.logger.error("File: index.ts ‚ùå, Line: 58, Function: configure; Configuration failed",{error:e,instanceId:this.instanceId}),e}}getInstanceId(){return this.instanceId}getQueueManager(){if(!this.isConfigured)throw o.logger.error("File: index.ts ‚ö†Ô∏è, Line: 64, Function: getQueueManager; Cleo must be configured before using"),new Error("Cleo must be configured before using");return this.queueManager}getWorker(e){return this.queueManager.getWorker(e)}task=r.task}t.Cleo=u;var c=s(433);Object.defineProperty(t,"QueueManager",{enumerable:!0,get:function(){return c.QueueManager}});var l=s(152);Object.defineProperty(t,"TaskGroup",{enumerable:!0,get:function(){return l.TaskGroup}});var g=s(308);Object.defineProperty(t,"TaskObserver",{enumerable:!0,get:function(){return g.TaskObserver}});var d=s(815);Object.defineProperty(t,"TaskState",{enumerable:!0,get:function(){return d.TaskState}}),Object.defineProperty(t,"TaskStatus",{enumerable:!0,get:function(){return d.TaskStatus}}),Object.defineProperty(t,"TaskPriority",{enumerable:!0,get:function(){return d.TaskPriority}}),Object.defineProperty(t,"LogLevel",{enumerable:!0,get:function(){return d.LogLevel}}),Object.defineProperty(t,"ObserverEvent",{enumerable:!0,get:function(){return d.ObserverEvent}}),Object.defineProperty(t,"GroupOperation",{enumerable:!0,get:function(){return d.GroupOperation}}),Object.defineProperty(t,"WorkerState",{enumerable:!0,get:function(){return d.WorkerState}});var p=s(587);Object.defineProperty(t,"Worker",{enumerable:!0,get:function(){return p.Worker}})},308:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TaskObserver=void 0;const r=s(749);t.TaskObserver=class{redis;subscriberClient;channelPrefix="taskObserver:";callbacks=new Map;constructor(e){this.redis=e,this.subscriberClient=e.duplicate(),this.setupSubscriber()}setupSubscriber(){this.subscriberClient.on("message",((e,t)=>{const s=this.getEventFromChannel(e),r=this.callbacks.get(s);if(r){const{taskId:e,status:s,data:a}=JSON.parse(t);r.forEach((t=>t(e,s,a)))}}))}subscribe(e,t){const s=this.getChannelName(e);this.callbacks.has(e)||this.callbacks.set(e,[]),this.callbacks.get(e).push(t),this.subscriberClient.subscribe(s).then((()=>{r.logger.debug("üëÄ TaskObserver: Subscribed to channel",{file:"taskObserver.ts",line:37,function:"subscribe",event:e,channel:s})})).catch((t=>{throw r.logger.error("‚ùå TaskObserver: Failed to subscribe",{file:"taskObserver.ts",line:38,function:"subscribe",event:e,error:t}),t}))}unsubscribe(e){const t=this.getChannelName(e);this.subscriberClient.unsubscribe(t).then((()=>{this.callbacks.delete(e),r.logger.debug("üëã TaskObserver: Unsubscribed from channel",{file:"taskObserver.ts",line:37,function:"unsubscribe",event:e,channel:t})}))}notify(e,t,s,a){const o=this.getChannelName(e),i=JSON.stringify({taskId:t,status:s,data:a});this.redis.publish(o,i).then((t=>{r.logger.debug("üì¢ TaskObserver: Message published",{file:"taskObserver.ts",line:46,function:"notify",event:e,channel:o,subscribers:t})}))}getChannelName(e){return`${this.channelPrefix}${e}`}getEventFromChannel(e){return e.replace(this.channelPrefix,"")}async close(){await this.subscriberClient.quit()}}},433:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.QueueManager=void 0;const r=s(377),a=s(815),o=s(749),i=s(481),n=s(308),u=s(152),c=s(587);t.QueueManager=class{queues;observer;groups;groupProcessingStrategy=a.GroupProcessingStrategy.ROUND_ROBIN;redis;instanceId;workers=new Map;isProcessing=!1;activeGroups=new Set;groupOrderKey="queue:group:processing-order";groupInfos=new Map;constructor(e="default",t=i.RedisInstance.DEFAULT,s={},r={}){this.instanceId=t,this.redis=i.redisConnection.getInstance(this.instanceId),this.queues=new Map,s.connection=this.redis,this.initializeQueue(e,s,r,this.instanceId),this.observer=new n.TaskObserver(this.redis),this.groups=new Map,this.setupTaskObservers()}initializeQueue(e,t={},s={},a="default"){t.connection=this.redis;const i=new r.Queue(e,t);this.queues.set(e,i),this.initializeWorker(e,s,a),o.logger.info("üÜï QueueManager: Queue initialized",{file:"queueManager.ts",line:50,function:"initializeQueue",queueName:e})}initializeWorker(e,t={},s="default"){const r=new c.Worker(e,t,s);r.setQueueManager(this),this.workers.set(e,r)}getWorker(e="default"){return this.workers.get(e)}getQueue(e){return this.queues.get(e)||null}async addTask(e,t,s={}){const r=s.queue||"default";let i=this.queues.get(r);i||(this.initializeQueue(r,{connection:this.redis}),i=this.queues.get(r));const n={id:s.id||`${e}-${Date.now()}`,name:e,data:t,options:s,state:a.TaskState.WAITING,retryCount:0,createdAt:new Date,updatedAt:new Date};if(s.group)return o.logger.debug("üë• QueueManager: Task belongs to group, deferring queue addition",{file:"queueManager.ts",line:90,function:"addTask",taskId:n.id,group:s.group}),n;const u={priority:s.priority,attempts:s.maxRetries,backoff:{type:"exponential",delay:s.retryDelay||3e3},removeOnComplete:s.removeOnComplete||!1,repeat:s.schedule?{pattern:s.schedule}:void 0},c=await i.add(e,t,u);return this.observer.notify(a.ObserverEvent.TASK_ADDED,n.id,a.TaskStatus.WAITING,n),{...n,state:await c.getState(),id:c.id}}async getTask(e,t="default"){const s=this.queues.get(t);if(!s)return o.logger.error("‚ùå QueueManager: Queue not found",{file:"queueManager.ts",line:150,function:"getTask",queueName:t}),null;const r=await s.getJob(e);return r?r.data:null}async getAllTasks(){return(await Promise.all(Array.from(this.queues.values()).map((async e=>e.getJobs())))).flat().map((e=>e.data))}async removeTask(e,t="default"){const s=this.queues.get(t);if(!s)return!1;const r=await s.getJob(e);return!!r&&(await r.remove(),!0)}async getGroup(e){return this.groups.has(e)||this.groups.set(e,new u.TaskGroup(this.redis,e)),this.groups.get(e)}async getGroupTasks(e){const t=await this.getGroup(e),s=await t.getTasks();return(await Promise.all(s.map((e=>this.getTask(e))))).filter((e=>null!==e))}async addTaskToGroup(e,t){const s=await this.getGroup(t);if(await s.addTask(e),this.groupInfos.has(t)||this.groupInfos.set(t,{name:t,priority:await this.getGroupPriority(t),lastProcessed:Date.now()}),this.activeGroups.add(t),this.observer.notify(a.ObserverEvent.GROUP_CHANGE,e,a.TaskStatus.ACTIVE,{group:t,operation:a.GroupOperation.ADD}),await s.getNextTask()===e){const s=await this.getTask(e);if(s){const r=s.options.queue||"default",a=this.queues.get(r);if(a){const r={priority:s.options.priority,attempts:s.options.maxRetries,backoff:{type:"exponential",delay:s.options.retryDelay||3e3},removeOnComplete:s.options.removeOnComplete||!1,repeat:s.options.schedule?{pattern:s.options.schedule}:void 0};await a.add(s.name,s.data,{...r,jobId:s.id}),o.logger.debug("‚û°Ô∏è QueueManager: Added group task to queue",{file:"queueManager.ts",line:160,function:"addTaskToGroup",taskId:e,group:t})}}}this.isProcessing||this.processGroupTasks().catch(console.error)}async getNextGroupByStrategy(){const e=Array.from(this.activeGroups);if(0===e.length)return null;switch(this.groupProcessingStrategy){case a.GroupProcessingStrategy.ROUND_ROBIN:return this.getNextRoundRobinGroup(e);case a.GroupProcessingStrategy.FIFO:return this.getNextFifoGroup(e);case a.GroupProcessingStrategy.PRIORITY:return this.getNextPriorityGroup(e);default:return e[0]}}async getNextGroupTask(){const e=await this.getNextGroupByStrategy();if(!e)return null;const t=await this.getGroup(e),s=await t.getNextTask();if(!s)return this.activeGroups.delete(e),this.groupInfos.delete(e),this.getNextGroupTask();const r=await this.getTask(s);if(r){const t=this.groupInfos.get(e);return t&&(t.lastProcessed=Date.now()),r}return null}async getNextRoundRobinGroup(e){const t=e.map((e=>this.groupInfos.get(e))).sort(((e,t)=>(e.lastProcessed||0)-(t.lastProcessed||0)));return t[0]?.name||null}async getNextFifoGroup(e){const t=e.map((e=>this.groupInfos.get(e))).sort(((e,t)=>(e.lastProcessed||0)-(t.lastProcessed||0)));return t[0]?.name||null}async getNextPriorityGroup(e){const t=(await Promise.all(e.map((async e=>({name:e,priority:await this.getGroupPriority(e)}))))).sort(((e,t)=>t.priority-e.priority));return t[0]?.name||null}async processGroupTasks(){if(!this.isProcessing){this.isProcessing=!0;try{for(;this.activeGroups.size>0;){const e=await this.getNextGroupByStrategy();if(!e)return void(this.isProcessing=!1);const t=await this.getGroup(e),s=await t.getNextTask();if(s){const t=await this.getTask(s);if(t){await this.processTask(t,e);const s=this.groupInfos.get(e);s&&(s.lastProcessed=Date.now())}}else this.activeGroups.delete(e),this.groupInfos.delete(e);await new Promise((e=>setTimeout(e,50)))}}finally{this.isProcessing=!1}}}async getGroupPriority(e){const t=`group:${e}:priority`,s=await this.redis.get(t);return s?parseInt(s,10):0}async setGroupPriority(e,t){const s=`group:${e}:priority`;await this.redis.set(s,t.toString());const r=this.groupInfos.get(e);r&&(r.priority=t),o.logger.info("‚ö° QueueManager: Group priority updated",{file:"queueManager.ts",line:200,function:"setGroupPriority",groupName:e,priority:t})}setGroupProcessingStrategy(e){this.groupProcessingStrategy=e,o.logger.info("‚öôÔ∏è QueueManager: Group processing strategy updated",{file:"queueManager.ts",line:210,function:"setGroupProcessingStrategy",strategy:e})}onTaskEvent(e,t){this.observer.subscribe(e,t)}offTaskEvent(e){this.observer.unsubscribe(e)}setupTaskObservers(){this.observer.subscribe(a.ObserverEvent.GROUP_CHANGE,((e,t,s)=>{s.operation===a.GroupOperation.ADD&&(this.activeGroups.add(s.group),this.isProcessing||this.processGroupTasks().catch(console.error))})),this.observer.subscribe(a.ObserverEvent.TASK_COMPLETED,(async(e,t,s)=>{if(s.group){const e=await this.getGroup(s.group);await e.hasAvailableTasks()||this.activeGroups.delete(s.group)}})),this.observer.subscribe(a.ObserverEvent.TASK_FAILED,(async(e,t,s)=>{s.group&&o.logger.error("‚ùå QueueManager: Task failed in group",{file:"queueManager.ts",line:70,function:"setupTaskObservers",taskId:e,group:s.group,error:s.error})})),this.observer.subscribe(a.ObserverEvent.TASK_PROGRESS,((e,t,s)=>{o.logger.debug("üìä QueueManager: Task progress update",{file:"queueManager.ts",line:82,function:"setupTaskObservers",taskId:e,progress:s.progress})}))}async processTask(e,t){try{const s=this.getWorker(e.options.queue||"default").getTaskHandler(e.name);if(!s)throw new Error(`No handler found for task ${e.name}`);const r=await s(e.data.args);e.result=r,e.state=a.TaskState.COMPLETED,await this.updateTask(e);const o=await this.getGroup(t);await o.completeTask(e.id),this.observer.notify(a.ObserverEvent.TASK_COMPLETED,e.id,a.TaskStatus.COMPLETED,{group:t,result:r})}catch(s){e.state=a.TaskState.FAILED,e.error=s instanceof Error?s.message:String(s),await this.updateTask(e),this.observer.notify(a.ObserverEvent.TASK_FAILED,e.id,a.TaskStatus.FAILED,{group:t,error:e.error})}}async updateTask(e){const t=e.options.queue||"default",s=this.queues.get(t);if(!s)throw new Error(`Queue ${t} not found`);const r=await s.getJob(e.id);if(!r)throw new Error(`Task ${e.id} not found`);await r.updateData({...e,updatedAt:new Date}),this.observer.notify(a.ObserverEvent.STATUS_CHANGE,e.id,e.state,e)}async close(){this.isProcessing=!1,await this.observer.close(),await Promise.all(Array.from(this.queues.values()).map((e=>e.close()))),this.queues.clear()}async completeGroupTask(e,t){const s=await this.getGroup(t);await s.completeTask(e);const r=await s.getNextTask();if(r){const e=await this.getTask(r);if(e){const s=e.options.queue||"default",a=this.queues.get(s);if(a){const s={priority:e.options.priority,attempts:e.options.maxRetries,backoff:{type:"exponential",delay:e.options.retryDelay||3e3},removeOnComplete:e.options.removeOnComplete||!1,repeat:e.options.schedule?{pattern:e.options.schedule}:void 0};await a.add(e.name,e.data,{...s,jobId:e.id}),o.logger.debug("‚û°Ô∏è QueueManager: Added next group task to queue",{file:"queueManager.ts",line:220,function:"completeGroupTask",taskId:r,group:t})}}}else this.activeGroups.delete(t),this.groupInfos.delete(t)}}},815:(e,t)=>{var s,r,a,o,i,n,u,c,l;Object.defineProperty(t,"__esModule",{value:!0}),t.GroupProcessingStrategy=t.GroupOperation=t.ObserverEvent=t.TaskStatus=t.QueueEvent=t.WorkerState=t.LogLevel=t.TaskPriority=t.TaskState=void 0,function(e){e.COMPLETED="completed",e.FAILED="failed",e.DELAYED="delayed",e.ACTIVE="active",e.WAITING="waiting",e.WAITING_CHILDREN="waiting-children",e.UNKNOWN="unknown"}(s||(t.TaskState=s={})),function(e){e[e.LOW=1]="LOW",e[e.NORMAL=2]="NORMAL",e[e.HIGH=3]="HIGH",e[e.CRITICAL=4]="CRITICAL"}(r||(t.TaskPriority=r={})),function(e){e.ERROR="error",e.WARN="warn",e.INFO="info",e.DEBUG="debug"}(a||(t.LogLevel=a={})),function(e){e.IDLE="IDLE",e.BUSY="BUSY",e.STOPPED="STOPPED",e.ERROR="ERROR"}(o||(t.WorkerState=o={})),function(e){e.TASK_ADDED="TASK_ADDED",e.TASK_STARTED="TASK_STARTED",e.TASK_COMPLETED="TASK_COMPLETED",e.TASK_FAILED="TASK_FAILED",e.TASK_RETRYING="TASK_RETRYING",e.WORKER_CONNECTED="WORKER_CONNECTED",e.WORKER_DISCONNECTED="WORKER_DISCONNECTED"}(i||(t.QueueEvent=i={})),function(e){e.WAITING="waiting",e.ACTIVE="active",e.COMPLETED="completed",e.FAILED="failed",e.DELAYED="delayed",e.PAUSED="paused",e.STALLED="stalled"}(n||(t.TaskStatus=n={})),function(e){e.TASK_ADDED="task_added",e.STATUS_CHANGE="status_change",e.PROGRESS_UPDATE="progress_update",e.GROUP_CHANGE="group_change",e.TASK_COMPLETED="task_completed",e.TASK_FAILED="task_failed",e.TASK_PROGRESS="task_progress",e.TASK_STALLED="task_stalled"}(u||(t.ObserverEvent=u={})),function(e){e.ADD="add",e.REMOVE="remove",e.PAUSE="pause",e.RESUME="resume",e.CLEAR="clear"}(c||(t.GroupOperation=c={})),function(e){e.ROUND_ROBIN="ROUND_ROBIN",e.FIFO="FIFO",e.PRIORITY="PRIORITY"}(l||(t.GroupProcessingStrategy=l={}))},749:function(e,t,s){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.logger=void 0,t.log=function(e,t,s){n.log(e,t,s)};const a=r(s(306)),o=s(815),i=a.default.format.combine(a.default.format.timestamp(),a.default.format.json(),a.default.format.printf((({timestamp:e,level:t,message:s,...r})=>{const a=Object.keys(r).length?JSON.stringify(r):"";return`${e} [${t.toUpperCase()}]: ${s} ${a}`}))),n=a.default.createLogger({level:process.env.LOG_LEVEL||o.LogLevel.INFO,format:i,transports:[new a.default.transports.Console({format:a.default.format.colorize({all:!0})}),new a.default.transports.File({filename:"logs/error.log",level:o.LogLevel.ERROR}),new a.default.transports.File({filename:"logs/combined.log"})]});t.logger=n,n.requestTracker=(e,t,s)=>{const r=Date.now();t.on("finish",(()=>{const s=Date.now()-r;n.info("File: logger.ts üåê, Line: 33, Function: requestTracker;",{method:e.method,url:e.url,status:t.statusCode,duration:`${s}ms`})})),s()}},587:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Worker=void 0;const r=s(377),a=s(481),o=s(815),i=s(308),n=s(749);class u extends r.Worker{registeredTasks=new Map;observer;queueManager=null;constructor(e,t={},s="default"){const r=a.redisConnection.getInstance(s);super(e,(async e=>{if(e.data.options?.group&&!await this.canProcessGroupedTask(e))return n.logger.debug("‚è≥ Worker: Task waiting in group",{file:"worker/index.ts",line:25,function:"processor",jobId:e.id,group:e.data.options.group}),await e.moveToDelayed(Date.now()+1e3),null;const t=this.registeredTasks.get(e.name);if(!t)throw new Error(`No handler registered for task ${e.name}`);try{n.logger.debug("üöÄ Worker: Processing task",{file:"worker/index.ts",line:40,function:"processor",jobId:e.id,name:e.name,group:e.data.options?.group});const s=await t(...e.data.args);return e.data.options?.group&&this.queueManager&&(await this.queueManager.completeGroupTask(e.id,e.data.options.group),n.logger.debug("‚úÖ Worker: Group task completed",{file:"worker/index.ts",line:55,function:"processor",jobId:e.id,group:e.data.options.group})),s}catch(t){throw n.logger.error("‚ùå Worker: Task processing failed",{file:"worker/index.ts",line:65,function:"processor",jobId:e.id,error:t}),t}}),{connection:r,...t}),this.observer=new i.TaskObserver(r),this.setObservers(this.observer)}async canProcessGroupedTask(e){if(!this.queueManager)return n.logger.warn("‚ö†Ô∏è Worker: QueueManager not connected",{file:"worker/index.ts",line:75,function:"canProcessGroupedTask"}),!1;try{const t=await this.queueManager.getGroup(e.data.options.group),s=await t.getNextTask(),r=s===e.id;return r||n.logger.debug("‚è≥ Worker: Task not next in group",{file:"worker/index.ts",line:90,function:"canProcessGroupedTask",jobId:e.id,group:e.data.options.group,nextTaskId:s}),r}catch(t){return n.logger.error("‚ùå Worker: Failed to check group task status",{file:"worker/index.ts",line:100,function:"canProcessGroupedTask",jobId:e.id,error:t}),!1}}setQueueManager(e){this.queueManager=e}getTaskHandler(e){return this.registeredTasks.get(e)}setObservers(e){this.observer=e,this.on("completed",(async(e,t)=>{this.observer.notify(o.ObserverEvent.TASK_COMPLETED,e.id,o.TaskStatus.COMPLETED,t)})),this.on("failed",((e,t)=>{this.observer.notify(o.ObserverEvent.TASK_FAILED,e.id,o.TaskStatus.FAILED,t)})),this.on("progress",((e,t)=>{this.observer.notify(o.ObserverEvent.TASK_PROGRESS,e.id,o.TaskStatus.ACTIVE,t)})),this.on("stalled",((e,t)=>{this.observer.notify(o.ObserverEvent.TASK_STALLED,e,o.TaskStatus.STALLED,t)}))}registerTask(e,t){this.registeredTasks.set(e,t)}getRegisteredTasks(){return Array.from(this.registeredTasks.keys())}}t.Worker=u},377:e=>{e.exports=require("bullmq")},446:e=>{e.exports=require("fastify")},657:e=>{e.exports=require("ioredis")},306:e=>{e.exports=require("winston")}},t={},s=function s(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,s),o.exports}(89);module.exports=s})();